/* REXX */
VERBOSE = 1
parse arg user APIKey paxFile .

 if paxfile == '' then do
    say "Syntax: bintrayget <user> <apikey> <pax file>"
    exit 4
 end

 call HTTP_getToolkitConstants
 if RESULT <> 0 then do
    exit fatalError( '** Environment error **' )
 end

 ConnectionHandle = ''
 RequestHandle = ''

 /* See C example at: https://github.com/IBM/zOS-Client-Web-Enablement-Toolkit/tree/master/Example-Download */
 /* See 'curl' format at https://github.com/zbrewdev/zbrew-cicd/blob/master/zbrewCICD.sh, RepoDownload: curl -ks -u${DEPLOY_USER}:${DEPLOY_API_KEY} ${artifact_url} -o ${paxfile} */

 ConnectionUri='http://dl.bintray.com'
 requestPath=paxFile

 ExpectedResponseStatus = 200
 ResponseStatusCode = ''
 ResponseReason = ''
 ResponseHeaders. = ''
 ResponseBody = ''

 call HTTP_init HWTH_HANDLETYPE_CONNECTION
 if RESULT <> 0 then do
    exit fatalError( 'Unable to initialize HTTP connection' )
 end

 call HTTP_setupConnection
 if RESULT <> 0 then do
    exit fatalError( 'Unable to setup HTTP connection' )
 end
 call HTTP_connect
 if RESULT <> 0 then do
    exit fatalError( 'Unable to make HTTP connection' )
 end
 call HTTP_init HWTH_HANDLETYPE_HTTPREQUEST
 if RESULT <> 0 then do
    exit fatalError( 'Unable to initialize HTTP REQUEST' )
 end
 call HTTP_setupRequest
 if RESULT <> 0 then do
    exit fatalError( 'Unable to setup HTTP REQUEST' )
 end
 call HTTP_request
 if RESULT <> 0 then do
    exit fatalError( 'Unable to make HTTP REQUEST' )
 end

 if ResponseStatusCode == ExpectedResponseStatus then do
    call writeData
 end
 else do
    exit fatalError( 'Bad response received: ' ResponseStatusCode ' from http request.' )
 end
 call HTTP_terminate RequestHandle, HWTH_NOFORCE
 call HTTP_disconnect
 call HTTP_terminate ConnectionHandle, HWTH_NOFORCE

 call closeToolkitTrace traceDD

 exit 0

 /*******************************************************************/
 /* Function:  writeData()                                          */
 /*                                                                 */
 /* Return 0 if successful                                          */
 /* -1 if otherwise.                                                */
 /*******************************************************************/
writeData:
trace 'o'

 payloadlength = LENGTH(ResponseBody)
 say 'Payload length <' payloadlength '>'
 if payloadlength == 0 then do
   say 'ResponseBody empty'
 end
 return 0

HTTP_getToolkitConstants:
  if VERBOSE then do
    say 'Setting hwtcalls on, syscalls sigoff'
  end
 call hwtcalls 'on'
 call syscalls 'SIGOFF'

 if VERBOSE then do
    say 'Including HWT Constants...'
 end
 address hwthttp "hwtconst " "ReturnCode " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwtconst', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwtconst (hwthttp) failure **' )
  end 

 return 0  

HTTP_init:
 HandleType = arg(1)
 ReturnCode = -1
 DiagArea. = ''
 address hwthttp "hwthinit " "ReturnCode " "HandleType " "HandleOut " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthinit', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthinit failure **' )
  end
 if HandleType == HWTH_HANDLETYPE_CONNECTION then do
    ConnectionHandle = HandleOut
 end
 else do
    RequestHandle = HandleOut
 end
 return 0  
 
HTTP_hwthset:
Parse Arg verbose, handle, key, val

  if verbose then do
    say key ' set to: ' val
  end
  ReturnCode = -1
  DiagArea. = ''
  address hwthttp "hwthset ReturnCode" handle "key val DiagArea."
  RexxRC = RC
  if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthset', RexxRC, ReturnCode, DiagArea.
    exit fatalError( '** hwthset ' key ' failure')
  end 
  return 0

HTTP_setupConnection:
trace 'o'

 if VERBOSE then do
   call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_VERBOSE", "HWTH_VERBOSE_ON"
   call TurnOnVerboseOutput
 end 

 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_URI", ConnectionUri 
 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_COOKIETYPE", "HWTH_COOKIETYPE_SESSION"
 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_USE_SSL", "HWTH_SSL_USE"
 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_SSLKEYTYPE", "HWTH_SSLKEYTYPE_KEYRINGNAME"
 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_SSLKEY", "*AUTH*/*"
 call HTTP_hwthset verbose, "ConnectionHandle", "HWTH_OPT_XDOMAIN_REDIRECTS", "HWTH_XDOMAIN_REDIRS_ALLOWED"

 if VERBOSE then do
    say 'Connection setup successful'
 end
 return 0 

HTTP_connect:
 if VERBOSE then do
    say 'Connect'
 end

 ReturnCode = -1
 DiagArea. = ''
 address hwthttp "hwthconn " "ReturnCode " "ConnectionHandle " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthconn', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthconn failure **' )
 end
 if VERBOSE then do
    say 'Connect (hwthconn) successful'
 end
 return 0 

HTTP_setupRequest:
trace 'o'
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_HTTPAUTH", "HWTH_HTTPAUTH_BASIC"
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_USERNAME", user
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_PASSWORD", APIKey
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_REQUESTMETHOD", "HWTH_HTTP_REQUEST_GET"
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_URI", requestPath
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_RESPONSEHDR_USERDATA", "ResponseHeaders."
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_TRANSLATE_RESPBODY", "HWTH_XLATE_RESPBODY_NONE"
 call HTTP_hwthset verbose, "RequestHandle", "HWTH_OPT_RESPONSEBODY_USERDATA", "ResponseBody"

 call HTTP_setRequestHeaders
 if RESULT <> 0 then do
    return fatalError( '** Unable to set Request Headers **' )
 end
 if VERBOSE then do
    say 'Request setup successful'
 end

 return 0

HTTP_disconnect:
 if VERBOSE then do
    say 'Disconnect'
 end

 ReturnCode = -1
 DiagArea. = ''
 address hwthttp "hwthdisc " "ReturnCode " "ConnectionHandle " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthdisc', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthdisc failure **' )
 end 
 if VERBOSE then do
    say 'Disconnect (hwthdisc) succeeded'
 end
 return 0 

HTTP_terminate:

 handleIn = arg(1)
 forceOption = arg(2)
 if VERBOSE then do
    say 'Terminate'
 end

 ReturnCode = -1
 DiagArea. = ''
 address hwthttp "hwthterm " "ReturnCode " "handleIn " "forceOption " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthterm', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthterm failure **' )
 end  
 if VERBOSE then do
    say 'Terminate (hwthterm) succeeded'
 end
 return 0

HTTP_request:
trace 'o'
 ReturnCode = -1
 DiagArea. = ''

 if VERBOSE then do
    say 'Making HTTP Request'
 end

 address hwthttp "hwthrqst " "ReturnCode " "ConnectionHandle " "RequestHandle " "HttpStatusCode " "HttpReasonCode " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthrqst', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthrqst failure **' )
 end

Say 'Response Body Length: ' LENGTH(ResponseBody)

 ResponseStatusCode = strip(HttpStatusCode,'L',0)
 ResponseReasonCode = strip(HttpReasonCode)
 return 0 

HTTP_setRequestHeaders:
trace 'o'
 SList = ''
 acceptMediaHeader = 'Accept:*/*' 
 acceptLanguageHeader = 'Accept-Language: en-US'
 hostHeader = 'Host: dl.bintray.com'
 /**********************************************************************/
 /* Create a brand new SList and specify the first header to be an     */
 /* "Accept" header that requests that the server return any response  */
 /* body text in JSON format.                                          */
 /**********************************************************************/
 ReturnCode = -1
 DiagArea. = ''
 if VERBOSE then do
    say 'Create new SList'
 end
 address hwthttp "hwthslst " "ReturnCode " "RequestHandle " "HWTH_SLST_NEW " "SList " "acceptMediaHeader " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthslst', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthslst (HWTH_SLST_NEW) failure **' )
 end  

 if VERBOSE then do
    say 'Append Accept:*/* to SList'
 end
 address hwthttp "hwthslst " "ReturnCode " "RequestHandle " "HWTH_SLST_APPEND " "SList " "acceptLanguageHeader " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthslst', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthslst (HWTH_SLST_APPEND) failure **' )
 end 

 if VERBOSE then do
    say 'Append Language'
 end
 address hwthttp "hwthslst " "ReturnCode " "RequestHandle " "HWTH_SLST_APPEND " "SList " "hostHeader " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthslst', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthslst (HWTH_SLST_APPEND) failure **' )
 end

 if VERBOSE then do
    say '****** Set HWTH_OPT_HTTPHEADERS for request ******'
 end
 ReturnCode = -1
 DiagArea. = ''
 address hwthttp "hwthset " "ReturnCode " "RequestHandle " "HWTH_OPT_HTTPHEADERS " "SList " "DiagArea."
 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthset', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthset (HWTH_OPT_HTTPHEADERS) failure **' )
 end 

 return 0


/*************************************************************/
/* Function:  HTTP_isError                                   */
/*                                                           */
/* Check the input processing codes. Note that if the input  */
/* RexxRC is nonzero, then the toolkit return code is moot   */
/* (the toolkit function was likely not even invoked). If    */
/* the toolkit return code is relevant, check it against the */
/* set of { HWTH_xx } return codes for evidence of error.    */
/* This set is ordered: HWTH_OK < HWTH_WARNING < ...         */
/* with remaining codes indicating error, so we may check    */
/* via single inequality.                                    */
/*                                                           */
/* Returns:  1 if any toolkit error is indicated, 0          */
/* otherwise.                                                */
/*************************************************************/
HTTP_isError:
 RexxRC = arg(1)
 if RexxRC <> 0 then
    return 1
 ToolkitRC = strip(arg(2),'L',0)
 if ToolkitRC == '' then
       return 0
 if ToolkitRC <= HWTH_WARNING then
       return 0
 return 1 

/*************************************************************/
/* Function:  HTTP_isWarning                                 */
/*                                                           */
/* Check the input processing codes. Note that if the input  */
/* RexxRC is nonzero, then the toolkit return code is moot   */
/* (the toolkit function was likely not even invoked). If    */
/* the toolkit return code is relevant, check it against the */
/* specific HWTH_WARNING return code.                        */
/*                                                           */
/* Returns:  1 if toolkit rc HWTH_WARNING is indicated, 0    */
/* otherwise.                                                */
/*************************************************************/
HTTP_isWarning:
 RexxRC = arg(1)
 if RexxRC <> 0 then
    return 0
 ToolkitRC = strip(arg(2),'L',0)
 if ToolkitRC == '' then
    return 0
 if ToolkitRC <> HWTH_WARNING then
    return 0
 return 1 

/***********************************************/
/* Procedure: HTTP_surfaceDiag()               */
/*                                             */
/* Surface input error information.  Note that */
/* when the RexxRC is nonzero, the ToolkitRC   */
/* and DiagArea content are moot and are       */
/* suppressed (so as to not mislead).          */
/***********************************************/
HTTP_surfaceDiag: procedure expose DiagArea.
  say
  say '*ERROR* ('||arg(1)||') at time: '||Time()
  say 'Rexx RC: '||arg(2)', Toolkit ReturnCode: '||arg(3)
  say 'DiagArea.Service: '||DiagArea.HWTH_service
  say 'DiagArea.ReasonCode: '||DiagArea.HWTH_reasonCode
  say 'DiagArea.ReasonDesc: '||DiagArea.HWTH_reasonDesc
  say
 return

fatalError:
 errorMsg = arg(1)
 say errorMsg
 return -1  

/***********************************************/
/* Function:  TurnOnVerboseOutput              */
/*                                             */
/* Allocates the trace dataset and sets the    */
/* output data set                             */
/***********************************************/
TurnOnVerboseOutput:
 /**********************************************************/
 say '****** Set HWTH_OPT_VERBOSE_OUTPUT for connection ******'
 traceDataSetName = '/tmp/bintrayget.out'
 traceDD = 'MYTRACE'

 allocRc = allocateDsnToolkitTracefile(traceDataSetName,traceDD)

 DiagArea. = ''
 address hwthttp "hwthset " "ReturnCode " "ConnectionHandle " "HWTH_OPT_VERBOSE_OUTPUT " "traceDD" "DiagArea."

 RexxRC = RC
 if HTTP_isError(RexxRC,ReturnCode) then do
    call HTTP_surfaceDiag 'hwthset', RexxRC, ReturnCode, DiagArea.
    return fatalError( '** hwthset (HWTH_OPT_VERBOSE) failure **')
 end /* endif hwthset failure */

 say 'Trace output location: 'traceDataSetName
 return

 /*************************************************/
 /* Procedure:  allocateDsnToolkitTracefile       */
 /*                                               */
 /* Allocate a previously created trace file      */
 /* with the required attributes (which           */
 /* must already exist), and a known DDname.      */
 /*************************************************/
allocateDsnToolkitTracefile: procedure expose (PROC_GLOBALS)
  /* datasetName = arg(1) */
  hfsName = arg(1) 
  DDname = arg(2)

  /* allocates datasetName to DDName and directs messages */
  /* to z/OS UNIX standard error (sdterr)                 */
  alloc = 'alloc fi('||DDname||') '
  /* alloc = alloc||'da('||quoted(datasetName)||') old msg(2)' */
  alloc = alloc||'path('||quoted(hfsName)') reuse msg(2)'
  call bpxwdyn alloc
  allocRc = Result
  say 'BPXWDYN Result: '||allocRc

  return allocRc  /* end procedure */

 /***********************************************************/
 /* Procedure:  closeToolkitTrace                           */
 /*                                                         */
 /* Free the ddname which an earlier redirectToolkitTraceXX */
 /* caused allocation to associate with an HFS file.        */
 /***********************************************************/
closeToolkitTrace: procedure expose (PROC_GLOBALS)
  DDname = arg(1)
  call bpxwdyn 'free fi('DDname')'
  return /* end procedure */

 /*******************************************************/
 /* Function:  quoted                                   */
 /*******************************************************/
 quoted:
  stringIn = arg(1)
 return "'"||stringIn||"'"
